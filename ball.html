<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meet</title>
    <link rel="stylesheet" href="style.css"/>

    
</head>
<body>
 
  <img src="assets/bg-img.jpeg" id= "bg-img">
  <!-- towers -->
  <img src="assets/opp-archer.png" id="opp-archer">
  <img src="assets/opp-king.png" id="opp-king">
  <img src="assets/our-archer.png" id="our-archer">
  <img src="assets/our-king.png" id="our-king">

  <!-- <img src="assets/elixir-bar.png" id = 'opp-bar'> -->
<div id="game-wrapper" style="position:relative; width:480px; height:720px;">
  <!-- Canvas -->
  <canvas id="canvas" width="480" height="720"
          ></canvas>

  <!-- Background/towers (hidden, used for ctx.drawImage) -->
  <img src="assets/bg-img.jpeg" id="bg-img" style="display:none;">
  <img src="assets/opp-archer.png" id="opp-archer0" style="display:none;">
  <img src="assets/opp-archer.png" id="opp-archer1" style="display:none;">

  <img src="assets/opp-king.png" id="opp-king" style="display:none;">
  <img src="assets/our-archer.png" id="our-archer0" style="display:none;">
  <img src="assets/our-archer.png" id="our-archer1" style="display:none;">

  <img src="assets/our-king.png" id="our-king" style="display:none;">

  <!-- Our deck -->
  <img src="assets/knight-p.png" id="our-knight" draggable="true"
       ondragstart="onDragStart(event, 'knight','our')">
  <img src="assets/valk-p.png" id="our-valk" draggable="true"
       ondragstart="onDragStart(event, 'valkyrie','our')">
  <img src="assets/pekka-p.png" id="our-pekka" draggable="true"
       ondragstart="onDragStart(event, 'pekka','our')">
  <img src="assets/giant-p.png" id="our-royal_giant" draggable="true"
       ondragstart="onDragStart(event, 'royal_giant','our')">

  <!-- Our bar -->
  <img src="assets/elixir-bar.png" id="our-bar">

  <!-- Opp deck -->
  <img src="assets/knight-p.png" id="opp-knight" draggable="true"
       ondragstart="onDragStart(event, 'knight','opp')">
  <img src="assets/valk-p.png" id="opp-valk" draggable="true"
       ondragstart="onDragStart(event, 'valkyrie','opp')">
  <img src="assets/pekka-p.png" id="opp-pekka" draggable="true"
       ondragstart="onDragStart(event, 'pekka','opp')">
  <img src="assets/giant-p.png" id="opp-royal_giant" draggable="true"
       ondragstart="onDragStart(event, 'royal_giant','opp')">

  <!-- Opp bar -->
  <img src="assets/elixir-bar.png" id="opp-bar">

  <!-- crown -->
  <img src="assets/crown-blue.png" id="crownblue" style="display:none;">
  <img src="assets/crown-red.png" id="crownred" style="display:none;">

  <!-- crown cusshion -->
  <img src="assets/red-cushion.png" id="cushionred" style="display:none;">
  <img src="assets/blue-cushion.png" id="cushionblue" style="display:none;">

</div>

    
     <script src="game-logic.js"></script>
     <script>
  (function () {
    // Network client for spawn-sync multiplayer
    const socket = io(); // connects to same origin; adjust if server on other host
    let roomId = null;
    let playerName = null;
    let connected = false;

    const statusEl = document.getElementById('net-status');
    const playersListEl = document.getElementById('players-list');
    const btnCreate = document.getElementById('btnCreate');
    const btnJoin = document.getElementById('btnJoin');
    const roomInput = document.getElementById('roomInput');
    const playerNameInput = document.getElementById('playerName');

    // canonical canvas values MUST match server's CANVAS_WIDTH / CANVAS_HEIGHT
    // Server provides these back on join/create. We'll trust server but also have fallbacks.
    let CANVAS_WIDTH = 480;
    let CANVAS_HEIGHT = 720;
    let PLAYERSIZE = typeof playersize !== 'undefined' ? playersize : 120;

    function setStatus(txt, color) {
      statusEl.textContent = txt;
      statusEl.style.color = color || '#fff';
    }

    // Replace player's makeActive with a wrapper that emits when local player spawns
    // Keep reference to original
    const _origMakeActive = window.makeActive;
    if (typeof _origMakeActive !== 'function') {
      console.warn("makeActive not found — network glue expects game-logic.js to define makeActive()");
    }

    // wrapper
    window.makeActive = function(type, x, y, opp_or_not) {
      // call original first (so the local spawn occurs immediately)
      try {
        _origMakeActive(type, x, y, opp_or_not);
      } catch (e) {
        console.error("makeActive wrapper: original threw", e);
      }

      // Only emit to server when:
      // - socket connected & in a room
      // - this spawn originated from the local player (opp_or_not === 'our')
      // - ai_mode is false (multiplayer)
      try {
        if (connected && roomId && opp_or_not === 'our') {
          // send coordinates in the client's canvas coordinate space (server uses canonical values)
          // If your client canvas size differs from server’s canonical size,
          // scale before emitting. For now assume both sides use 480x720.
          const payload = {
            room_id: roomId,
            char: type,
            x: x,
            y: y,
            meta: { fromName: playerName || null }
          };
          socket.emit('spawn', payload);
          // optional local debug:
          // console.log('[net] emitted spawn', payload);
        }
      } catch (e) {
        console.error("makeActive wrapper emit error", e);
      }
    };

    // Handle incoming spawns from the server (other player's spawn)
    socket.on('spawn_broadcast', function (payload) {
      // payload: { from_sid, char, x, y, meta, mirror: true }
      // On receiving side, spawn as opponent (opp)
      try {
        const { char, x, y, meta } = payload;
        // call original makeActive with 'opp' to mark it as opponent spawn
        // Use original reference to ensure our wrapper won't re-emit.
        _origMakeActive(char, x, y, 'opp');
        // optional debug overlay
        // console.log('[net] received spawn', payload);
      } catch (e) {
        console.error("spawn_broadcast handler error", e);
      }
    });

    socket.on('spawn_ack', function (payload) {
      // server acknowledged our spawn; optional handling
      // console.debug('[net] spawn ack', payload);
    });

    // connection / room lifecycle handlers
    socket.on('connect', () => {
      connected = true;
      setStatus('Connected to server', '#8ef7a1');
    });

    socket.on('disconnect', () => {
      connected = false;
      setStatus('Disconnected', '#ff8f8f');
      roomId = null;
      playersListEl.textContent = '';
    });

    socket.on('room_created', function (data) {
      roomId = data.room_id;
      CANVAS_WIDTH = data.settings.canvas_width || CANVAS_WIDTH;
      CANVAS_HEIGHT = data.settings.canvas_height || CANVAS_HEIGHT;
      PLAYERSIZE = data.settings.playersize || PLAYERSIZE;
      setStatus('Room created: ' + roomId, '#aaf');
      playersListEl.textContent = 'Players: ' + data.players.map(p => p.name).join(', ');
    });

    socket.on('joined_room', function (data) {
      roomId = data.room_id;
      CANVAS_WIDTH = data.settings.canvas_width || CANVAS_WIDTH;
      CANVAS_HEIGHT = data.settings.canvas_height || CANVAS_HEIGHT;
      PLAYERSIZE = data.settings.playersize || PLAYERSIZE;
      setStatus('Joined room: ' + roomId, '#aaf');
      playersListEl.textContent = 'Players: ' + data.players.map(p => p.name).join(', ');
    });

    socket.on('player_joined', function (data) {
      // data: {sid, name}
      // update players list by asking server for room state (cheap)
      if (!roomId) return;
      socket.emit('get_room_state', { room_id: roomId });
    });

    socket.on('player_left', function (data) {
      // update players list
      if (!roomId) return;
      socket.emit('get_room_state', { room_id: roomId });
    });

    socket.on('room_state', function (data) {
      if (data.error) {
        // ignore
        return;
      }
      if (data.id === roomId) {
        const names = (data.players||[]).map(p => p.name).join(', ');
        playersListEl.textContent = 'Players: ' + names;
      }
    });

    // Create / Join UI handlers
    btnCreate.addEventListener('click', function () {
      playerName = (playerNameInput.value || 'Player').trim();
      socket.emit('create_room', { name: playerName });
      setStatus('Creating room...', '#ffd');
    });
    btnJoin.addEventListener('click', function () {
      const rid = (roomInput.value || '').trim();
      if (!rid) {
        setStatus('Enter room id to join', '#ffd');
        return;
      }
      playerName = (playerNameInput.value || 'Player').trim();
      socket.emit('join_room', { room_id: rid, name: playerName });
      setStatus('Joining room ' + rid + '...', '#ffd');
    });

    // Start with a quick poll to see if socket is ready
    setTimeout(() => {
      if (!connected) setStatus('Not connected to server yet', '#f7f7f7');
    }, 800);

    // Helpful: when page unloads, leave room politely
    window.addEventListener('beforeunload', () => {
      if (roomId) {
        socket.emit('leave_room', { room_id: roomId });
      }
      try { socket.disconnect(); } catch(e){}
    });

    // Optional: prevent duplicate scheduleAiSpawn running in multiplayer. If you run AI scheduling in game-logic,
    // make sure to stop it when connected to a real opponent. We can't access scheduleAiSpawn easily here,
    // but you can call stopAiSpawn() in console or modify game-logic to stop it when network connected.
  })();
  </script>

</body>
</html>

   <!-- <h1>Ball Tutorial</h1> -->
    <!-- <div class="button-container">
  <button draggable="true" ondragstart="onDragStart(event, 'PEKKA','opp')">PEKKA</button>
<button draggable="true" ondragstart="onDragStart(event, 'Valkyrie','opp')">Valkyrie</button>
<button draggable="true" ondragstart="onDragStart(event, 'knight','opp')">Wizard</button>
<button draggable="true" ondragstart="onDragStart(event, 'Giant','opp')">Giant</button>
</div>
     -->
  <!-- our deck -->
<!-- <img src="assets/giant-p.png" id="our-giant"> 
<img src="assets/pekka-p.png" id="our-pekka">
<img src="assets/valk-p.png" id="our-valk">
<img src="assets/wizard-p.png" id="our-wiz"> -->

<!-- opp deck -->
<!-- <img src="assets/giant-p.png" id="opp-giant"> 
<img src="assets/pekka-p.png" id="opp-pekka">
<img src="assets/valk-p.png" id="opp-valk">
<img src="assets/wizard-p.png" id="opp-wiz"> -->

<!-- our deck -->
<!-- <img src="assets/giant-p.png" id="our-giant" draggable="true" ondragstart="onDragStart(event, 'giant','our')">
<img src="assets/pekka-p.png" id="our-pekka" draggable="true" ondragstart="onDragStart(event, 'pekka','our')">
<img src="assets/valk-p.png" id="our-valk" draggable="true" ondragstart="onDragStart(event, 'valk','our')">
<img src="assets/wizard-p.png" id="our-wiz" draggable="true" ondragstart="onDragStart(event, 'wizard','our')"> -->

<!-- opp deck -->
<!-- <img src="assets/giant-p.png" id="opp-giant" draggable="true" ondragstart="onDragStart(event, 'giant','opp')">
<img src="assets/pekka-p.png" id="opp-pekka" draggable="true" ondragstart="onDragStart(event, 'pekka','opp')">
<img src="assets/valk-p.png" id="opp-valk" draggable="true" ondragstart="onDragStart(event, 'valk','opp')">
<img src="assets/wizard-p.png" id="opp-wiz" draggable="true" ondragstart="onDragStart(event, 'wizard','opp')"> -->


<!-- ourbar -->
<!-- <img src="assets/elixir-bar.png" id = 'our-bar'> -->
<!-- oppbar -->


<!-- <div class="button-container">
  <button draggable="true" ondragstart="onDragStart(event, 'PEKKA','our')">PEKKA</button>
<button draggable="true" ondragstart="onDragStart(event, 'Valkyrie','our')">Valkyrie</button>
<button draggable="true" ondragstart="onDragStart(event, 'Wizard','our')">Wizard</button>
<button draggable="true" ondragstart="onDragStart(event, 'Giant','our')">Giant</button>
</div> -->

<!-- <img src="assets/bg-img.jpeg" id="bg-img"> -->
  

<!-- 
yeh tb tk krna h jb tk hum target ke nearby 10 pixel tk nhi phuch jaate 
phla test case uske sidha fornt me h 
50-250=-200 mtlb piceh
toh h ki 
humara x=50 y=50 h toh
samne wale ka oppx = 50 hoga and oppy=250 hoga
agar humara or uska ex lgbhag like 5 ke margin me h 
hume ulta chl ke jana h
while(x,y aprroximately of 10 pixels oppx and opp y ke pass nhi ajate   )
if (x-10<oppx<x+10){
if(y-oppy<0)// piche {
we have to move backwardd;

}
else{
we have to move forward
}
}
else{ // x door h x range se bhar h toh hume left rigt jana pd skt ah 
if(x-oppx<0) 50-100 let say 50-100 toh < 0 {
we have to move right 
}
else {
we have to move left 
}
}




function moveToTarget(x, y, oppx, oppy, step = 1) {
    while (!(Math.abs(x - oppx) <= 10 && Math.abs(y - oppy) <= 10)) {

        // X ko adjust karo
        if (x < oppx) {
            x += step;
            process.stdout.write("Move Right | ");
        } else if (x > oppx) {
            x -= step;
            process.stdout.write("Move Left | ");
        }

        // Y ko adjust karo
        if (y < oppy) {
            y += step;
            console.log("Move Backward");
        } else if (y > oppy) {
            y -= step;
            console.log("Move Forward");
        }
    }

    console.log(`Reached near target: (${x}, ${y})`);
}

// Example
moveToTarget(50, 50, 250, 250);

-->
